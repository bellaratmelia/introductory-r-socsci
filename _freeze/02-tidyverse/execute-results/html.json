{
  "hash": "93d254a91a24f157ed6b24ef852eadca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Wrangling with Tidyverse\"\nauthor: \"Bella Ratmelia\"\nformat: revealjs\n---\n\n\n\n## Today's Outline\n\n1.  Loading our data into RStudio environment\n2.  Data wrangling with `dplyr` and `tidyr` (part of the `tidyverse` package)\n\n## Checklist when you start RStudio\n\n-   Load the project we created last session and open the R script file.\n-   Make sure that `Environment` panel is empty (click on broom icon to clean it up)\n-   Clear the `Console` and `Plots` too.\n-   Re-run the `library(tidyverse)` and `read_csv` portion in the previous session\n\n## Refresher: Loading from CSV into a dataframe\n\nUse `read_csv` from `readr` package (part of `tidyverse`) to load our data into a dataframe\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# import tidyverse library\nlibrary(tidyverse)\n\n# read the CSV and save into a dataframe called chile_data\nchile_data <- read_csv(\"data/chile_voting.csv\")\n\n# \"peek at the data, pay attention to the data types!\nglimpse(chile_data)\n```\n:::\n\n\n\n## Cleaning data for analysis\n\n::: incremental\n-   **Why do it in R?** Because it's much efficient to do so in R, especially if your data is large (e.g. millions of rows, hundreds of columns) and you have repetitive clean up tasks.\n-   Incorrect or inconsistent data can lead to false conclusions, so it's important to clean and prep it correctly.\n-   Having a clear understanding of the desired data shape is essential as real data often differs from what you imagine! **Refer to codebook, actual questionnaire, appendix for guidance.**\n-   Data cleaning techniques differ based on the problems, data type, and the research questions you are trying to answer. Various methods are available, each with its own trade-offs.\n:::\n\n## About dplyr and tidyr\n\n-   Packages from `tidyverse`. ([click here to go to the tidyverse homepage](https://www.tidyverse.org/))\n\n-   Posit have created cheatsheets here! (you can have this open in another tab for reference for this session!)\n\n    -   [dplyr cheatsheet](https://rstudio.github.io/cheatsheets/html/data-transformation.html) \\| [pdf version](https://rstudio.github.io/cheatsheets/data-transformation.pdf) (I personally prefer this PDF version since it's more visual)\n\n    -   [tidyr cheatsheet](https://rstudio.github.io/cheatsheets/html/tidyr.html) \\| [pdf version](https://rstudio.github.io/cheatsheets/tidyr.pdf)\n\n## About the data\n\nThe data is from a national survey conducted in April and May of 1988 by FLACSO/Chile, capturing voting intentions for the [1988 Chilean plebiscite](https://en.wikipedia.org/wiki/1988_Chilean_presidential_referendum). The dataset contains information about respondents' demographic characteristics and their voting intentions. This data can also be found from `carData` package! (more on this later)\n\nKey variables in the dataset:\n\n------------------------------------------------------------------------\n\n| Variable     | Description                                                                                                          |\n|--------------|----------------------------------------------------------------------------------------------------------------------|\n| `region`     | Region of voters: `C` (Central), `M` (Metropolitan Santiago area), `N` (North), `S` (South), `SA` (city of Santiago) |\n| `population` | Population size of respondent's community                                                                            |\n| `sex`        | Sex of voters: `F` (female), `M` (male)                                                                              |\n| `age`        | Age in years                                                                                                         |\n| `education`  | Education level of voters: `P` (Primary), `PS` (Post-secondary), `S` (Secondary)                                     |\n| `income`     | Monthly income, in Pesos                                                                                             |\n| `statusquo`  | Scale of support for the status-quo in numerical value                                                               |\n| `vote`       | Voter's decision: `A` (will abstain), `N` (will vote no), `U` (undecided), `Y` (will vote yes)                       |\n\n: Explanatory notes on each column\n\n## Prelim checks for your data\n\nIt's good practice to do some preliminary checks on your data to get a better sense of it!\n\nA few things that you can do:\n\n-   Check for duplicates\n\n-   Check for missing values\n\n-   Check on overall distributions of the categorical data\n\n-   Plot the distribution of the numerical/continuous data\n\n## Data wrangling activities specific to our data\n\n**Scenario**: We are a junior Research Assistant (RA) in a research team currently studying about the 1988 Chilean plebiscite. The team's primary goal is to identify any discernible and interesting patterns in the voter demographic data.\n\nAs a start, we have been asked to do the following data cleaning and processing tasks:\n\n::: incremental\n1.  Remove all rows with empty values (NA)\n\n2.  Separate the demographic information (region, sex, age, education) into a separate CSV called `chile-demographics.csv`\n\n3.  Retrieve only respondents aged 30 or older, arrange it from oldest to youngest, and save it into a separate CSV called `chile-30plus.csv`\n\n4.  Make the character columns such as `region`, `sex`, `education`, and `vote` to be in uppercase.\n\n5.  Convert all the categorical columns such as `region`, `sex`, `education`, and `vote` to Factor. Make sure `education` is ordered.\n:::\n\n------------------------------------------------------------------------\n\n::: incremental\n6.  Create a new column called `age_group` that categorizes age into groups: \"18-29\", \"30-44\", \"45-59\", \"60+\".\n\n7.  Create a new column called `high_income` that is TRUE if income is above the median, FALSE otherwise.\n\n8.  Create a new column called `support_level` that categorizes `statusquo` into \"Unsupportive\" (\\<= 0) and \"Supportive\" (\\> 0). Save all of these changes you made from step 3 onwards into a new CSV called `chile_voting_processed.csv`\n\n9.  Generate summary stats of `income` grouped by `region` and `education`. The summary stats should include mean, median, max, min, std, and n (number of observations).\n\n10. Reshape the data to have `region` as rows and `vote` options as columns, with the values being the count of votes for each option in each region.\n:::\n\n# Let's wrangle our data!\n\n## Task #1\n\n> **A strategy I'd like to recommend:** briefly read over the `dplyr` + `tidyr` documentation, either the PDF or HTML version, and have them open on a separate tab so that you can refer to it quickly.\n\nRemove all rows with empty values (NA)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchile_data <- chile_data |> \n  drop_na()\n```\n:::\n\n\n\nThe number of observations after all rows containing NAs are removed:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(chile_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2431    8\n```\n\n\n:::\n:::\n\n\n\n## Interlude: Pipe Operator ( \\|\\> )\n\n-   The pipe operator (\\|\\>) allows us to chain multiple operations without creating intermediate dataframes.\n\n-   Super handy when we perform several data wrangling tasks using tidyverse in sequence.\n\n-   Helps with readability, especially for complex operations.\n\n-   Keyboard shortcut: `Ctrl`+`Shift`+`M` on Windows, `Cmd`+`Shift`+`M` on Mac\n\n::: panel-tabset\n### Without pipe operator\nNotice that we have to create a \"temp\" dataframes called `age_df` and `age_df_desc` in this method.\n\n``` r\nage_df <- filter(chile_data, age >= 30)\nage_df_desc <- arrange(age_df, desc(age))\nwrite_csv(age_df_desc, \"data-output/chile-30plus.csv\")\n```\n\n### With pipe operator\n\nNo \"temp\" dataframe needed here! :D\n\n``` {.r code-overflow=\"overflow\"}\nchile_data |> \n    filter(age >= 30) |> \n    arrange(desc(age)) |> \n    write_csv(\"data-output/chile-30plus.csv\")\n```\n:::\n\n## Task #2\n\nSeparate the demographic information (region, sex, age, education) into a separate CSV called `chile-demographics.csv`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# not using the |> operator here!\n\ndemographics_df <- select(chile_data, region, sex, age, education)\nwrite_csv(demographics_df, \"data-output/chile-demographics.csv\")\n```\n:::\n\n\n\nThe first few rows in the CSV:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,431 × 4\n  region sex     age education\n  <chr>  <chr> <dbl> <chr>    \n1 N      M        65 P        \n2 N      M        29 PS       \n3 N      F        38 P        \n# ℹ 2,428 more rows\n```\n\n\n:::\n:::\n\n\n\n## Task #3\n\nRetrieve only respondents aged 30 or older, arrange it from oldest to youngest, and save it into a separate CSV called `chile-30plus.csv`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchile_data |> \n    filter(age >= 30) |> \n    arrange(desc(age)) |> \n    write_csv(\"chile-30plus.csv\")\n```\n:::\n\n\n\nThe first few rows in the resulting CSV:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,581 × 8\n  region population sex     age education income statusquo vote \n  <chr>       <dbl> <chr> <dbl> <chr>      <dbl>     <dbl> <chr>\n1 N          125000 F        70 P          15000     1.49  Y    \n2 N          250000 F        70 P          75000     1.40  Y    \n3 N          250000 M        70 P           7500    -0.366 N    \n# ℹ 1,578 more rows\n```\n\n\n:::\n:::\n\n\n\n## Group exercise 1 (solo attempts ok)\n\n[**Time: 5 minutes!**]{.underline}\n\nRetrieve only respondents from the Metropolitan Santiago area (`M`), with Secondary education (`S`), and who are undecided (`U`) about their vote. Keep only their `region`, `education`, `vote`, and `income` columns in a new dataframe called `santiago_undecided` in **descending** order of `income`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\nsantiago_undecided <- chile_data |> \n    filter(region == \"M\" & education == \"S\" & vote == \"U\") |> \n    select(region, education, vote, income) |> \n    arrange(desc(income)) \n```\n:::\n\n\n\nThe first few rows of `santiago_undecided`:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  region education vote  income\n  <chr>  <chr>     <chr>  <dbl>\n1 M      S         U      35000\n2 M      S         U      15000\n3 M      S         U      15000\n# ℹ 2 more rows\n```\n\n\n:::\n:::\n\n\n\n## Task #4\n\nMake all character columns such as `region`, `sex`, `education`, and `vote` to be in uppercase.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncols_to_change <- c(\"region\", \"sex\", \"education\", \"vote\")\nchile_data <- chile_data |> \n    mutate(across(cols_to_change, toupper))\n```\n:::\n\n\n\nThe end result:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,431 × 4\n  region sex   education vote \n  <chr>  <chr> <chr>     <chr>\n1 N      M     P         Y    \n2 N      M     PS        N    \n3 N      F     P         Y    \n# ℹ 2,428 more rows\n```\n\n\n:::\n:::\n\n\n\n## Task #5\n\nConvert all the categorical columns such as `region`, `sex`, `education`, and `vote` to Factor. Make sure `education` is ordered.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchile_data <- chile_data |> \n    mutate(across(cols_to_change, as.factor))\n\n#reordering\nchile_data <- chile_data |> \n    mutate(education = factor(education, \n                         levels = c(\"P\", \"S\", \"PS\"), \n                         ordered = TRUE))\n```\n:::\n\n\n\nThe structure of education column after the change:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [2,431 × 1] (S3: tbl_df/tbl/data.frame)\n $ education: Ord.factor w/ 3 levels \"P\"<\"S\"<\"PS\": 1 3 1 1 2 1 3 2 1 1 ...\n```\n\n\n:::\n:::\n\n\n\n## Task #6\n\nAdd a new column to `chile_data` called `age_group` that categorizes age into groups: \"18-29\", \"30-44\", \"45-59\", \"60+\".\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchile_data <- chile_data |> \n    mutate(age_group = case_when(\n        age < 30 ~ \"18-29\",\n        age < 45 ~ \"30-44\",\n        age < 60 ~ \"45-59\",\n        TRUE ~ \"60+\"\n    ))\n```\n:::\n\n\n\nThe new age_group column should look something like this:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,431 × 2\n    age age_group\n  <dbl> <chr>    \n1    65 60+      \n2    29 18-29    \n3    38 30-44    \n4    49 45-59    \n# ℹ 2,427 more rows\n```\n\n\n:::\n:::\n\n\n\n## Task #7\n\nCreate a new column called `high_income` that is TRUE if income is above the median, FALSE otherwise.\n\nhint: you need to calculate the median income first.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian_income <- median(chile_data$income, na.rm = TRUE)\nchile_data <- chile_data |> \n    mutate(high_income = income > median_income)\n```\n:::\n\n\n\nThe original income column and the new high_income column:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  income high_income\n   <dbl> <lgl>      \n1  15000 FALSE      \n2  15000 FALSE      \n3  15000 FALSE      \n```\n\n\n:::\n:::\n\n\n\n## Task #8 - Can you solve this?\n\nCreate a new column called `support_level` that categorizes `statusquo` into \"Unsupportive\" (\\<= 0) and \"Supportive\" (\\> 0).\n\nSave all of these changes you made from step 3 onwards into a new CSV called `chile_voting_processed.csv`\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\nchile_data <- chile_data |> \n    mutate(support_level = case_when(\n        statusquo <= 0 ~ \"Unsupportive\",\n        statusquo > 0 ~ \"Supportive\",\n        TRUE ~ NA_character_\n    ))\n\nwrite_csv(chile_data, \"data-output/chile_voting_processed.csv\")\n```\n:::\n\n\n\nThe new support_level column:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,431 × 2\n  statusquo support_level\n      <dbl> <chr>        \n1      1.01 Supportive   \n2     -1.30 Unsupportive \n3      1.23 Supportive   \n# ℹ 2,428 more rows\n```\n\n\n:::\n:::\n\n\n\n## Task #9\n\nGenerate summary stats of `income` grouped by `region` and `education`. The summary stats should include mean, median, max, min, std, and n (number of observations).\n\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nlibrary(gt)\nchile_data |> \n    group_by(region, education) |> \n    summarise(observation = n(), \n              mean_income = mean(income, na.rm = TRUE),\n              median_income = median(income, na.rm = TRUE), \n              highest = max(income, na.rm = TRUE),\n              lowest = min(income, na.rm = TRUE),\n              std_dev = sd(income, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 8\n# Groups:   region [5]\n   region education observation mean_income median_income highest lowest std_dev\n   <fct>  <ord>           <int>       <dbl>         <dbl>   <dbl>  <dbl>   <dbl>\n 1 C      P                 238      16450.         15000  200000   2500  18483.\n 2 C      S                 234      35887.         35000  200000   2500  36540.\n 3 C      PS                 76      64375          35000  200000   7500  50705.\n 4 M      P                  43      21163.         15000  125000   2500  21967.\n 5 M      S                  26      29038.         25000   75000   7500  19787.\n 6 M      PS                  6      60000          55000  125000  15000  39875.\n 7 N      P                 133      19173.         15000   75000   2500  15823.\n 8 N      S                 111      31937.         35000  125000   2500  26351.\n 9 N      PS                 61      53934.         35000  200000   7500  41772.\n10 S      P                 310      15677.          7500  200000   2500  19074.\n11 S      S                 250      29800          15000  200000   2500  30450.\n12 S      PS                 95      56658.         35000  200000   2500  52879.\n13 SA     P                 278      19191.         15000  125000   2500  15796.\n14 SA     S                 389      41292.         35000  200000   2500  41052.\n15 SA     PS                181      82859.         75000  200000   7500  66268.\n```\n\n\n:::\n:::\n\n\n\n## Task #10\n\nReshape the data to have `region` as rows and `vote` options as columns, with the values being the count of votes for each option in each region.\n\nTo achieve this clean table look, we can use `gt` package or `knitr` package!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchile_data |>\n    group_by(region, vote) |>\n    summarise(count = n(), .groups = \"drop\") |>\n    pivot_wider(names_from = vote, values_from = count, values_fill = 0) |> \n    knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|region |  A|   N|   U|   Y|\n|:------|--:|---:|---:|---:|\n|C      | 44| 209| 130| 165|\n|M      |  2|  17|  19|  37|\n|N      | 29|  98|  46| 132|\n|S      | 39| 209| 140| 267|\n|SA     | 63| 334| 216| 235|\n\n\n:::\n:::\n\n\n\n## Long vs Wide Data\n\n::: columns\n::: {.column width=\"50%\"}\n**Long data:**\n\n-   Each row is a unique observation.\n\n-   There is a separate column indicating the variable or type of measurements\n\n-   This format is more \"understandable\" by R, more suitable for visualizations.\n\n:::\n\n::: {.column width=\"50%\"}\n**Wide data:**\n\n-   Each row is a unique observation.\n\n-   Each column is a variable --\\> the more variables you have, the \"wider\" is the data\n\n-   This format is more intuitive for humans!\n:::\n:::\n\n## Long vs Wide Data: Examples\n\n::: columns\n::: {.column width=\"50%\"}\n**Long data:**\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 3\n   region vote  count\n   <fct>  <fct> <int>\n 1 C      A        44\n 2 C      N       209\n 3 C      U       130\n 4 C      Y       165\n 5 M      A         2\n 6 M      N        17\n 7 M      U        19\n 8 M      Y        37\n 9 N      A        29\n10 N      N        98\n11 N      U        46\n12 N      Y       132\n13 S      A        39\n14 S      N       209\n15 S      U       140\n16 S      Y       267\n17 SA     A        63\n18 SA     N       334\n19 SA     U       216\n20 SA     Y       235\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n**Wide data:**\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n  region     A     N     U     Y\n  <fct>  <int> <int> <int> <int>\n1 C         44   209   130   165\n2 M          2    17    19    37\n3 N         29    98    46   132\n4 S         39   209   140   267\n5 SA        63   334   216   235\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n## Group exercise 3 (solo attempts ok)\n\n[**Time: 5 minutes**]{.underline}\n\nGenerate a summary stats of `age` grouped by `region` and `sex`. The summary stats should include mean, median, max, min, std, and n (number of observations). It should look something like this:\n\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\nchile_data |> \n    group_by(region, sex) |> \n    summarise(observation = n(), \n              mean_age = mean(age, na.rm = TRUE),\n              median_age = median(age, na.rm = TRUE), \n              oldest = max(age, na.rm = TRUE),\n              youngest = min(age, na.rm = TRUE),\n              std_dev = sd(age, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 8\n# Groups:   region [5]\n   region sex   observation mean_age median_age oldest youngest std_dev\n   <fct>  <fct>       <int>    <dbl>      <dbl>  <dbl>    <dbl>   <dbl>\n 1 C      F             269     37.7       36       70       18    14.3\n 2 C      M             279     39.1       36       70       18    15.8\n 3 M      F              43     37.0       36       68       18    14.1\n 4 M      M              32     36         33.5     65       18    13.5\n 5 N      F             159     38.7       36       70       18    13.8\n 6 N      M             146     38.7       35       70       18    16.6\n 7 S      F             330     36.7       35       70       18    13.9\n 8 S      M             325     38.0       36       70       18    14.9\n 9 SA     F             449     38.9       38       70       18    14.0\n10 SA     M             399     39.0       37       70       18    15.1\n```\n\n\n:::\n:::\n\n\n\n## Bonus: Deleting columns from dataframe\n\nLet's say I have this column called `wrong_column` that I want to remove:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchile_data <- chile_data |> mutate(wrong_column = \"random values\")\nchile_data |> select(region, wrong_column) |> print(n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,431 × 2\n  region wrong_column \n  <fct>  <chr>        \n1 N      random values\n2 N      random values\n3 N      random values\n# ℹ 2,428 more rows\n```\n\n\n:::\n:::\n\n\n\n## Remove the wrong column with subset `-`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchile_data <- chile_data |> \n    select(-wrong_column)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,431 × 1\n  region\n  <fct> \n1 N     \n2 N     \n3 N     \n# ℹ 2,428 more rows\n```\n\n\n:::\n:::\n\n\n\n# End of Session 2!\n\nNext session: Descriptive stats and data visualization with `ggplot2` package.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}