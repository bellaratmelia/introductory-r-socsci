{
  "hash": "22df5da01ab6e74f7201f1af0232cd66",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Wrangling with Tidyverse\"\nauthor: \"Bella Ratmelia\"\nformat: revealjs\n---\n\n\n\n\n\n\n## Today's Outline\n\n1.  Loading our data into RStudio environment\n2.  Data wrangling with `dplyr` and `tidyr` (part of the `tidyverse` package)\n\n## Checklist when you start RStudio\n\n-   Load the project we created last session and open the R script file. Click on `File` \\> `Recent Projects...` \\> Select the our project from last week.\n-   Make sure that `Environment` panel is empty (click on broom icon to clean it up).\n-   Clear the `Console` and `Plots` too.\n-   Re-run the `library(tidyverse)` and `read_csv` portion in the previous session (the code is also on the next slide if you missed last week's session)\n\n## Refresher: Loading from CSV into a dataframe\n\nUse `read_csv` from `readr` package (part of `tidyverse`) to load our World Values Survey data. More information about the data can be found under the `Dataset` tab in the course website.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# import tidyverse library\nlibrary(tidyverse)\n\n# read the CSV and save into a dataframe called wvs_data\nwvs_data <- read_csv(\"data/wvs-wave7-sg-ca-nz.csv\")\n\n# \"peek\" at the data, pay attention to the data types!\nglimpse(wvs_data)\n```\n:::\n\n\n\n\n\n\n## Cleaning data for analysis\n\n::: incremental\n-   **Why do it in R?** Because it's much efficient to do so in R, especially if your data is large (e.g. millions of rows, thousands of columns) and you have repetitive clean up tasks.\n-   Incorrect or inconsistent data can lead to false conclusions, so it's important to clean and prep it correctly.\n-   Having a clear understanding of the desired data shape is essential as real data often differs from what you imagine! **Refer to codebook, actual questionnaire, appendix for guidance.**\n-   Data cleaning techniques differ based on the problems, data type, and the research questions you are trying to answer. Various methods are available, each with its own trade-offs.\n:::\n\n## About dplyr and tidyr\n\n-   Packages from `tidyverse`. ([click here to go to the tidyverse homepage](https://www.tidyverse.org/))\n\n-   Posit have created cheatsheets here! (you can have this open in another tab for reference for this session!)\n\n    -   [dplyr cheatsheet](https://rstudio.github.io/cheatsheets/html/data-transformation.html) \\| [pdf version](https://rstudio.github.io/cheatsheets/data-transformation.pdf) (I personally prefer this PDF version since it's more visual)\n\n    -   [tidyr cheatsheet](https://rstudio.github.io/cheatsheets/html/tidyr.html) \\| [pdf version](https://rstudio.github.io/cheatsheets/tidyr.pdf)\n\n-   Most of the time, these are the ones that you will use quite often:\n\n    -   `drop_na()` - remove rows with null values\n\n    -   `select()` - to select column(s) from a dataframe\n\n    -   `filter()` - to filter rows based on criteria\n\n    -   `mutate()` - to compute new columns or edit existing ones\n\n    -   `if_else()` and `case_when()` - to be used with mutate when we want to compute/edit columns based on multiple criteria\n\n    -   `group_by()` and `summarize()` - group data and summarize each group\n\n## Scenario: Data wrangling activities with WVS data {.smaller}\n\n**Scenario**: We are research assistants analyzing patterns in values and satisfaction across different countries and demographic groups. \n\nOur team has been assigned to explore and get insights on how specific factors (employment, work importance, marital status, political alignment, financial satisfaction, and religiosity) may relate to life satisfaction among different generations (Gen Z, Millennials, Gen X, and Baby Boomer), including how they may differ between the 3 countries. \n\nTo ensure the analysis quality, we were instructed to discard incomplete data.\n\nWe can break down the tasks as such:\n\n::: incremental\n1.  Remove all rows with missing values (NA)\n\n2.  Check for duplicates\n\n3.  Select only the relevant columns: demographic columns, `work_importance`, `life_satisfaction`, `financial_satisfaction`, `religiousity`, `political_scale`, `marital_status`, and `employment`. \n\n4.  Filter for respondents aged 18 or older. Optionally, we can then arrange the dataset by age (oldest to youngest)\n\n5.  Reverse-code `importance` variables so that higher numbers consistently represent higher levels of the measured construct. In other words, 1 = Not at all important and 4 = Very important.\n\n6.  Create age groups for each generation: \"18-28\", \"29-44\", \"45-60\", \"61+\"\n:::\n\nOnce we did all of the wrangling above, we can save this \"wrangled\" version into another CSV\n\n\n# Let's wrangle our data!\n\n## Task #1\n\n> **A strategy I'd like to recommend:** briefly read over the `dplyr` + `tidyr` documentation, either the PDF or HTML version, and have them open on a separate tab so that you can refer to it quickly.\n\nRemove all rows with empty values (NA) with `drop_na()`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data <- wvs_data |> \n  drop_na()\n```\n:::\n\n\n\n\n\n\nThe number of observations after removing NAs:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(wvs_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6403   16\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Task #2\n\nCheck for duplicates with `distinct()`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data <- wvs_data |> \n  distinct(ID, .keep_all = TRUE)\n```\n:::\n\n\n\n\n\n\n\n(Our data has no duplicates, but this is still a good practice to do, especially if we were combining data from multipe sources)\n\n\n## Interlude: Pipe Operator ( \\|\\> )\n\n-   The pipe operator (\\|\\>) allows us to chain multiple operations without creating intermediate / temporary dataframes.\n\n-   Super handy when we perform several data wrangling tasks using tidyverse in sequence.\n\n-   Helps with readability, especially for complex operations.\n\n-   Keyboard shortcut: `Ctrl`+`Shift`+`M` on Windows, `Cmd`+`Shift`+`M` on Mac\n\n::: panel-tabset\n### Without pipe operator\n\nNotice that we have to create a \"temp\" dataframes called `wvs_data_clean` in this method.\n\n``` r\nwvs_data <- drop_na(wvs_data)\nwvs_data_clean <- wvs_data_clean(wvs_data, desc(age))\nwrite_csv(wvs_data_clean, \"data-output/wvs-clean.csv\")\n```\n\n### With pipe operator\n\nNo \"temporary\" dataframe needed here! :D\n\n``` {.r code-overflow=\"overflow\"}\nwvs_data |> \n    drop_na() |> \n    distinct(ID, .keep_all = TRUE) |> \n    write_csv(\"data-output/wvs-30plus.csv\")\n```\n:::\n\n## Task #3:\n\nSelect only the relevant columns: demographic columns,  `life_satisfaction`, `work_importance`, `financial_satisfaction`, `religiousity`, `political_scale`, `marital_status`, and `employment`.\n\nWe can achieve this with `select()`!\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data <- wvs_data |>\n    select(country, sex, birthyear, age, life_satisfaction, work_importance, financial_satisfaction, religiousity, political_scale, marital_status, employment) \n```\n:::\n\n\n\n\n\n\nPreview of the filtered data:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 6,403\nColumns: 11\n$ country                <chr> \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\"…\n$ sex                    <chr> \"Female\", \"Male\", \"Female\", \"Male\", \"Male\", \"Ma…\n$ birthyear              <dbl> 1944, 1951, 1984, 1975, 1988, 1982, 1981, 1985,…\n$ age                    <dbl> 76, 69, 35, 45, 32, 38, 38, 34, 65, 31, 27, 33,…\n$ life_satisfaction      <dbl> 5, 8, 9, 7, 1, 7, 9, 6, 7, 6, 7, 10, 8, 10, 6, …\n$ work_importance        <dbl> 1, 1, 2, 2, 2, 1, 1, 2, 1, 2, 1, 2, 4, 1, 3, 3,…\n$ financial_satisfaction <dbl> 8, 2, 8, 8, 9, 8, 9, 5, 6, 9, 5, 7, 9, 9, 7, 8,…\n$ religiousity           <chr> \"A religious person\", \"A religious person\", \"An…\n$ political_scale        <dbl> 10, 5, 2, 8, 6, 6, 7, 5, 6, 4, 5, 4, 1, 7, 2, 8…\n$ marital_status         <chr> \"Separated\", \"Married\", \"Living together as mar…\n$ employment             <chr> \"Retired/pensioned\", \"Retired/pensioned\", \"Part…\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Task #4:\n\nFilter for respondents aged 18 or older. Optionally, we can then arrange the dataset by age (oldest to youngest)\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data <- wvs_data |> \n    filter(age >= 18) |> \n    arrange(desc(age))\n```\n:::\n\n\n\n\n\n\nChecking the structure:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(wvs_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 11\n  country sex    birthyear   age life_satisfaction work_importance\n  <chr>   <chr>      <dbl> <dbl>             <dbl>           <dbl>\n1 CAN     Male        1927    93                 7               1\n2 NZL     Female      1928    91                 5               4\n3 SGP     Male        1930    90                 8               1\n4 CAN     Female      1931    89                 6               3\n5 CAN     Female      1930    89                 6               4\n6 CAN     Male        1931    89                 8               4\n# ℹ 5 more variables: financial_satisfaction <dbl>, religiousity <chr>,\n#   political_scale <dbl>, marital_status <chr>, employment <chr>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Task #5\n\nReverse-code `work_importance` variables so that higher numbers consistently represent higher levels of the measured construct. In other words, 1 = Not at all important and 4 = Very important.\n\nWe can achieve this with `mutate()`!\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data <- wvs_data |>\n    mutate(work_importance_r = 5 - work_importance)\n```\n:::\n\n\n\n\n\n\nPreview of age groups:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data |>\n    select(work_importance_r, work_importance) |>\n    print(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,403 × 2\n  work_importance_r work_importance\n              <dbl>           <dbl>\n1                 4               1\n2                 1               4\n3                 4               1\n4                 2               3\n5                 1               4\n# ℹ 6,398 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Task #6\n\nCreate age groups for each generation: \"18-28\", \"29-44\", \"45-60\", \"61+\"\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data <- wvs_data |>\n    mutate(age_group = case_when(\n        age <= 28 ~ \"18-28\",\n        age <= 44 ~ \"29-44\",\n        age <= 60 ~ \"45-60\",\n        TRUE ~ \"61+\"\n    ))\n```\n:::\n\n\n\n\n\n\nPreview of age groups:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data |>\n    select(age, age_group) |>\n    print(n = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,403 × 2\n    age age_group\n  <dbl> <chr>    \n1    93 61+      \n2    91 61+      \n3    90 61+      \n4    89 61+      \n# ℹ 6,399 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Checkpoint 1 - saving our hard work into a CSV file\n\nWe have done some cleaning! Let's save this cleaned data into a separate CSV file called \"wvs_cleaned_v1.csv\"\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data |> write_csv(\"data-output/wvs_cleaned_v1.csv\")\n```\n:::\n\n\n\n\n\n\nCheck the data output folder to make sure the CSV is created!\n\n## Group Exercise 1 (5 minutes)\n\nNow that we have a new file, load this new `wvs_cleaned_v1.csv` into a new dataframe called `wvs_cleaned`. Filter to respondents from Singapore who are currently employed full time. Show only the country, the employment status, and age. Use `glimpse()` or `print()` to check the result! (you can chain these functions at the end)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\nlibrary(tidyverse)\nwvs_cleaned <- read_csv(\"data-output/wvs_cleaned_v1.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 6403 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (6): country, sex, religiousity, marital_status, employment, age_group\ndbl (7): birthyear, age, life_satisfaction, work_importance, financial_satis...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\nwvs_cleaned |> \n    filter(country == \"SGP\" & employment == \"Full time\") |> \n    select(country, employment, age) |> \n    glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 857\nColumns: 3\n$ country    <chr> \"SGP\", \"SGP\", \"SGP\", \"SGP\", \"SGP\", \"SGP\", \"SGP\", \"SGP\", \"SG…\n$ employment <chr> \"Full time\", \"Full time\", \"Full time\", \"Full time\", \"Full t…\n$ age        <dbl> 81, 79, 73, 70, 69, 68, 68, 68, 68, 68, 68, 67, 67, 67, 67,…\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n## Scenario: Data wrangling activities with WVS data (continued)\n\nOnce we are done with the wrangling part, we can proceed with simple descriptive analysis!\n\n::: incremental\n\n7.  Before we proceed further, convert the appropriate categorical variables (country, religiousity, sex, marital_status, employment) to **Factor**\n\n8.  Generate summary statistics of life_satisfaction grouped by country\n\n9.  Create a new column called `satisfaction_group` that indicate whether each respondent has higher or lower than average `life_satisfaction` \n\n10. Reshape the data to show average satisfaction scores by country and age group\n:::\n\n## Task #7\n\nLet's use the `wvs_cleaned` dataframe for this task.\n\nConvert the appropriate categorical variables (country, religiousity, sex, marital_status, employment) to **Factor**.\n\nWe can do this with `mutate()` and `as_factor()` from forcats, another sub-package within tidyverse. \n\n\n\n\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nwvs_cleaned <- wvs_cleaned |> \n    mutate(\n        country = as_factor(country),\n        religiousity = as_factor(religiousity),\n        sex = as_factor(sex),\n        marital_status = as_factor(marital_status),\n        employment = as_factor(employment)\n    )\n\n# check conversion result\nstr(wvs_cleaned)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [6,403 × 13] (S3: tbl_df/tbl/data.frame)\n $ country               : Factor w/ 3 levels \"CAN\",\"NZL\",\"SGP\": 1 2 3 1 1 1 2 1 1 2 ...\n $ sex                   : Factor w/ 2 levels \"Male\",\"Female\": 1 2 1 2 2 1 2 1 2 1 ...\n $ birthyear             : num [1:6403] 1927 1928 1930 1931 1930 ...\n $ age                   : num [1:6403] 93 91 90 89 89 89 89 88 88 88 ...\n $ life_satisfaction     : num [1:6403] 7 5 8 6 6 8 9 8 8 10 ...\n $ work_importance       : num [1:6403] 1 4 1 3 4 4 2 1 4 2 ...\n $ financial_satisfaction: num [1:6403] 7 5 9 9 8 8 10 10 5 10 ...\n $ religiousity          : Factor w/ 4 levels \"Not a religious person\",..: 1 2 2 1 1 2 2 2 2 2 ...\n $ political_scale       : num [1:6403] 5 3 3 2 5 5 8 10 5 5 ...\n $ marital_status        : Factor w/ 6 levels \"Widowed\",\"Single\",..: 1 1 1 1 2 3 1 1 1 1 ...\n $ employment            : Factor w/ 8 levels \"Part time\",\"Retired/pensioned\",..: 1 2 2 2 2 2 2 2 2 2 ...\n $ work_importance_r     : num [1:6403] 4 1 4 2 1 1 3 4 1 3 ...\n $ age_group             : chr [1:6403] \"61+\" \"61+\" \"61+\" \"61+\" ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\nRstudio may auto-suggest `as.factor()` from base R. You can use this as well, but `as_factor()` is preferred since we are using tidyverse approach. \n\n## Task #7 - the shortcut\n\nIf we have a lot of columns to convert, that might be troublesome to type! This is where `across()` can come in handy. \n\nLet's first define a character vector that contains the names of columns we plan to convert.\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumns_to_convert <- c(\"country\", \"religiousity\", \"sex\", \"marital_status\", \"employment\")\n```\n:::\n\n\n\n\n\n\nWe will use this vector with `mutate()` and `across()`. We tell tidyverse to convert all of the columns with the help of `all_of()`\n\n\n\n\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nwvs_cleaned <- wvs_cleaned |> \n    mutate(across(all_of(columns_to_convert), as_factor))\n\n# check conversion result\nstr(wvs_cleaned)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [6,403 × 13] (S3: tbl_df/tbl/data.frame)\n $ country               : Factor w/ 3 levels \"CAN\",\"NZL\",\"SGP\": 1 2 3 1 1 1 2 1 1 2 ...\n $ sex                   : Factor w/ 2 levels \"Male\",\"Female\": 1 2 1 2 2 1 2 1 2 1 ...\n $ birthyear             : num [1:6403] 1927 1928 1930 1931 1930 ...\n $ age                   : num [1:6403] 93 91 90 89 89 89 89 88 88 88 ...\n $ life_satisfaction     : num [1:6403] 7 5 8 6 6 8 9 8 8 10 ...\n $ work_importance       : num [1:6403] 1 4 1 3 4 4 2 1 4 2 ...\n $ financial_satisfaction: num [1:6403] 7 5 9 9 8 8 10 10 5 10 ...\n $ religiousity          : Factor w/ 4 levels \"Not a religious person\",..: 1 2 2 1 1 2 2 2 2 2 ...\n $ political_scale       : num [1:6403] 5 3 3 2 5 5 8 10 5 5 ...\n $ marital_status        : Factor w/ 6 levels \"Widowed\",\"Single\",..: 1 1 1 1 2 3 1 1 1 1 ...\n $ employment            : Factor w/ 8 levels \"Part time\",\"Retired/pensioned\",..: 1 2 2 2 2 2 2 2 2 2 ...\n $ work_importance_r     : num [1:6403] 4 1 4 2 1 1 3 4 1 3 ...\n $ age_group             : chr [1:6403] \"61+\" \"61+\" \"61+\" \"61+\" ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n`across()` is used for applying the same function to multiple columns in a single `mutate()` or `summarise()` operation.\n\n\n## Task #8\n\nGenerate summary statistics  such as count (n), mean, median, and standard deviation of life_satisfaction grouped by country. \n\nWe can achieve this with `group_by()` and `summarise()`\n\n\n\n\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nwvs_data |>\n    group_by(country, age_group) |>\n    summarise(\n        n = n(),\n        mean_satisfaction = mean(life_satisfaction),\n        median_satisfaction = median(life_satisfaction),\n        sd_satisfaction = sd(life_satisfaction)\n    ) |>\n    arrange(country, desc(mean_satisfaction))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'country'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 6\n# Groups:   country [3]\n   country age_group     n mean_satisfaction median_satisfaction sd_satisfaction\n   <chr>   <chr>     <int>             <dbl>               <dbl>           <dbl>\n 1 CAN     61+        1013              7.55                   8            1.59\n 2 CAN     29-44      1232              6.99                   7            1.80\n 3 CAN     45-60      1061              6.92                   7            1.87\n 4 CAN     18-28       712              6.60                   7            1.86\n 5 NZL     61+         292              7.96                   8            1.66\n 6 NZL     45-60       222              7.38                   8            1.90\n 7 NZL     29-44       119              7.32                   8            1.69\n 8 NZL     18-28        27              6.70                   7            1.98\n 9 SGP     61+         418              7.17                   7            1.84\n10 SGP     29-44       511              7.09                   7            1.70\n11 SGP     45-60       550              7.05                   7            1.83\n12 SGP     18-28       246              6.85                   7            1.68\n```\n\n\n:::\n:::\n\n\n\n\n\n\n*What if we want to save this into a CSV? What if we also want to group by country AND age_group?*\n\n## Task #9\n\nCreate a new column called `satisfaction_group` that indicate whether each respondent has higher or lower than average `life_satisfaction` \n\n\n\n\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nmean_satisfaction <- mean(wvs_data$life_satisfaction, na.rm = TRUE)\n\nwvs_data |>\n    mutate(satisfaction_group = if_else(\n        life_satisfaction > mean_satisfaction,\n        \"higher\", # if condition is fulfilled, do this\n        \"lower\" # otherwise, do this\n    )) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,403 × 14\n   country sex    birthyear   age life_satisfaction work_importance\n   <chr>   <chr>      <dbl> <dbl>             <dbl>           <dbl>\n 1 CAN     Male        1927    93                 7               1\n 2 NZL     Female      1928    91                 5               4\n 3 SGP     Male        1930    90                 8               1\n 4 CAN     Female      1931    89                 6               3\n 5 CAN     Female      1930    89                 6               4\n 6 CAN     Male        1931    89                 8               4\n 7 NZL     Female      1930    89                 9               2\n 8 CAN     Male        1932    88                 8               1\n 9 CAN     Female      1958    88                 8               4\n10 NZL     Male        1931    88                10               2\n# ℹ 6,393 more rows\n# ℹ 8 more variables: financial_satisfaction <dbl>, religiousity <chr>,\n#   political_scale <dbl>, marital_status <chr>, employment <chr>,\n#   work_importance_r <dbl>, age_group <chr>, satisfaction_group <chr>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Task #10\n\nShow the average satisfaction scores by country and age group in wide data format\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data |>\n    group_by(country, age_group) |>\n    summarise(\n        avg_satisfaction = mean(life_satisfaction, na.rm = TRUE),\n    ) |>\n    pivot_wider(\n        names_from = age_group,\n        values_from = avg_satisfaction\n    ) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'country'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n# Groups:   country [3]\n  country `18-28` `29-44` `45-60` `61+`\n  <chr>     <dbl>   <dbl>   <dbl> <dbl>\n1 CAN        6.60    6.99    6.92  7.55\n2 NZL        6.70    7.32    7.38  7.96\n3 SGP        6.85    7.09    7.05  7.17\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Long vs Wide Data\n\n::::: columns\n::: {.column width=\"50%\"}\n**Long data:**\n\n-   Each row is a unique observation.\n\n-   There is a separate column indicating the variable or type of measurements\n\n-   This format is more \"understandable\" by R, more suitable for visualizations.\n:::\n\n::: {.column width=\"50%\"}\n**Wide data:**\n\n-   Each row is a unique observation.\n\n-   Each column is a variable --\\> the more variables you have, the \"wider\" is the data\n\n-   This format is more intuitive for humans!\n:::\n:::::\n\n## Long vs Wide Data: Examples\n\n::::: columns\n::: {.column width=\"50%\"}\n**Long data:**\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'country'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n# Groups:   country [3]\n   country age_group count\n   <chr>   <chr>     <int>\n 1 CAN     18-28       712\n 2 CAN     29-44      1232\n 3 CAN     45-60      1061\n 4 CAN     61+        1013\n 5 NZL     18-28        27\n 6 NZL     29-44       119\n 7 NZL     45-60       222\n 8 NZL     61+         292\n 9 SGP     18-28       246\n10 SGP     29-44       511\n11 SGP     45-60       550\n12 SGP     61+         418\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n::: {.column width=\"50%\"}\n**Wide data:**\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n# Groups:   country [3]\n  country `18-28` `29-44` `45-60` `61+`\n  <chr>     <int>   <int>   <int> <int>\n1 CAN         712    1232    1061  1013\n2 NZL          27     119     222   292\n3 SGP         246     511     550   418\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n:::::\n\n## Group exercise 2 (solo attempts ok)\n\n[**Time: 5 minutes**]{.underline}\n\nGenerate a summary stats of `age` grouped by `country` and `sex`. The summary stats should include mean, median, max, min, std, and n (number of observations). It should look something like this:\n\n\n\n\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show answer\"}\nwvs_data |> \n    group_by(country, sex) |> \n    summarise(observation = n(), \n              mean_age = mean(age, na.rm = TRUE),\n              median_age = median(age, na.rm = TRUE), \n              oldest = max(age, na.rm = TRUE),\n              youngest = min(age, na.rm = TRUE),\n              std_dev = sd(age, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'country'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 8\n# Groups:   country [3]\n  country sex    observation mean_age median_age oldest youngest std_dev\n  <chr>   <chr>        <int>    <dbl>      <dbl>  <dbl>    <dbl>   <dbl>\n1 CAN     Female        1959     44.2         42     89       18    17.0\n2 CAN     Male          2059     48.8         49     93       18    16.4\n3 NZL     Female         354     56.6         58     91       19    15.5\n4 NZL     Male           306     57.3         59     88       20    15.4\n5 SGP     Female         919     47.7         47     87       21    15.3\n6 SGP     Male           806     47.9         48     90       21    16.2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Bonus: Deleting columns from dataframe\n\nLet's say I have this column called `wrong_column` that I want to remove:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data <- wvs_data |> mutate(wrong_column = \"random values\")\nwvs_data |> select(country, wrong_column) |> print(n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,403 × 2\n  country wrong_column \n  <chr>   <chr>        \n1 CAN     random values\n2 NZL     random values\n3 SGP     random values\n# ℹ 6,400 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Remove the wrong column with subset `-`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data <- wvs_data |> \n    select(-wrong_column)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwvs_data |> select(country) |> print(n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,403 × 1\n  country\n  <chr>  \n1 CAN    \n2 NZL    \n3 SGP    \n# ℹ 6,400 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n# End of Session 2!\n\nNext session: Descriptive statistics and data visualization with `ggplot2` package - we'll create visualizations to explore patterns in life satisfaction, values, and demographics across countries!\n",
    "supporting": [
      "02-tidyverse_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}